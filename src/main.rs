use std::process::Command;
use reqwest::blocking::get;
use serde_json::Value;
use std::collections::HashSet;
use dotenv::dotenv; 
use std::env;

// Función que obtiene los servicios y versiones usando Nmap
fn get_nmap_services(target: &str) -> Vec<String> {
    let output = Command::new("nmap")
        .arg("-sV")
        .arg(target)
        .output()
        .expect("Failed to execute Nmap");

    let result = String::from_utf8_lossy(&output.stdout);
    let mut services = Vec::new();
    let lines = result.lines();
    
    for line in lines {
        if line.contains("/tcp") {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                let service = parts[2].to_string();
                let version = if parts.len() > 3 { parts[3] } else { "unknown" }.to_string();
                services.push(format!("{} {}", service, version));
            }
        }
    }

    services
}

// Función que busca vulnerabilidades en NVD usando la API y los servicios obtenidos por Nmap
fn search_cves_for_service(service: &str) -> Option<Value> {
    let nvd_api_url = format!("https://services.nvd.nist.gov/rest/json/cves/2.0?keyword={}", service);

    let response = get(&nvd_api_url).expect("Failed to send request to NVD API");

    if response.status().is_success() {
        let body = response.text().expect("Failed to read response body");
        let json: Value = serde_json::from_str(&body).expect("Failed to parse JSON");
        Some(json)
    } else {
        eprintln!("Error: NVD API returned status code {}", response.status());
        None
    }
}

// Función que busca si la vulnerabilidad está en Metasploit
fn search_in_msf(cve_id: &str) -> bool {
    let msf_command = Command::new("msfconsole")
        .arg("-q")
        .arg("-x")
        .arg(format!("search {}", cve_id))
        .output()
        .expect("Failed to execute Metasploit");

    let result = String::from_utf8_lossy(&msf_command.stdout);
    
    if result.contains("Exploit") || result.contains("Auxiliary") {
        println!("Found exploit module for {}", cve_id);
        true
    } else {
        println!("No exploit found for {}", cve_id);
        false
    }
}

// Función principal para procesar las vulnerabilidades
fn process_vulnerabilities_for_service(service: &str) {
    if let Some(cve_data) = search_cves_for_service(service) {
        if let Some(cves) = cve_data["vulnerabilities"].as_array() {
            for cve in cves {
                let cve_id = cve["cve"]["id"].as_str().unwrap_or("unknown");
                let summary = cve["cve"]["description"]["description_data"][0]["value"]
                    .as_str()
                    .unwrap_or("No description");

                println!("CVE ID: {}", cve_id);
                println!("Description: {}", summary);

                // Buscar el CVE en Metasploit
                let msf_found = search_in_msf(cve_id);
                if msf_found {
                    println!("Metasploit exploit available for {}.", cve_id);
                }
            }
        }
    }
}

fn main() {
    // Cargar las variables de entorno desde el archivo .env
    dotenv().ok();

    // Obtener el objetivo de la variable de entorno
    let target = env::var("target").expect("TARGET not set in .env file");

    // Obtener los servicios y versiones mediante Nmap
    let services = get_nmap_services(&target);
    
    // Definir servicios no importantes
    let non_important_services: HashSet<&str> = vec![
        "http", "ftp", "smtp", "pop3", "imap", // Ejemplos de servicios menos relevantes
        "netbios-ssn", "microsoft-ds", "msrpc", // Ejemplos de servicios de Windows
    ].into_iter().collect();

    // Procesar cada servicio encontrado por Nmap
    for service in services {
        let service_name = service.split_whitespace().next().unwrap_or("");
        if non_important_services.contains(service_name) {
            println!("Ignoring non-important service: {}", service_name);
            continue;
        }

        println!("Searching CVEs for service: {}", service);
        process_vulnerabilities_for_service(&service);
    }
}
